/**
 * collector@1.0.0 https://github.com/EvitcaStudio/Collector
 * Compiled 1/9/2024, 9:34:17 AM UTC
 * 
 * collector is licensed under a MIT styled License. See LICENSE.md for more info.
 * 
 * Copyright 2024, Evitca Studio, All Rights Reserved
 */
 var e={d:(t,o)=>{for(var l in o)e.o(o,l)&&!e.o(t,l)&&Object.defineProperty(t,l,{enumerable:!0,get:o[l]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},o={};e.d(o,{P:()=>l});class t{version="1.0.0";static DiobConstructor=(()=>{var e=VYLO.newDiob(),t=e.__proto__.constructor;return VYLO.delDiob(e),t})();collectionLimit=20;static WARNING_LIMIT=200;basicCollection=[];setMaxLimit(e){"number"==typeof e&&(this.collectionLimit=Math.round(e),this.collectionLimit>l.WARNING_LIMIT)&&console.warn("Collector: This is a high value to use for a max limit in a collection! Only use this high of a value if you know what you are doing.")}collect(o,l){const n=Array.isArray(o);if(o)if("object"!=typeof o||n||Object.keys(o).length)if(o.type||n){if(Array.isArray(l)){if(l.includes(o))return void console.error("Collector: OOPS! %cpCollected","font-weight: bold","already belongs to the provided collection.");if(n&&!o.length)return void console.error("Collector: OOPS! %cpCollected","font-weight: bold","is an array. But it contains nothing to recycle.");if(n){if(l.length>=this.collectionLimit){for(let e=o.length-1;0<=e;e--){const n=o[e];n instanceof t.DiobConstructor?(this.cleanInstance(n),VYLO.delDiob(n)):(this.cleanInstance(n),VYLO.delObject(n))}return}if(o.length+l.length>this.collectionLimit)for(let e=o.length-(this.collectionLimit-l.length);0<e;e--){const l=o[e];l instanceof t.DiobConstructor?(o.splice(e,1),this.cleanInstance(l),VYLO.delDiob(l)):(o.splice(e,1),this.cleanInstance(l),VYLO.delObject(l))}for(let e=o.length-1;0<=e;e--){const n=o[e];"function"==typeof n.onCollected&&n.onCollected(),l.includes(n)||l.push(n),this.cleanInstance(n)}return}return l.length>=this.collectionLimit?void(o instanceof t.DiobConstructor?(this.cleanInstance(o),VYLO.delDiob(o)):(this.cleanInstance(o),VYLO.delObject(o))):("function"==typeof o.onCollected&&o.onCollected(),l.includes(o)||l.push(o),void this.cleanInstance(o))}console.error("Collector: Invalid variable type passed for the %cpCollection","font-weight: bold","parameter. Expecting an array. Collect failed.")}else console.error("Collector: OOPS! %cpCollected","font-weight: bold"," is not a valid object It has no type.");else console.error("Collector: OOPS! %cpCollected","font-weight: bold"," is an empty object and will NOT be collected.");else console.error("Collector: There was nothing passed for the %cpCollected","font-weight: bold","parameter. Expecting a instance or an object.")}isInCollection(t="Diob",o=1,l=[],...n){var c,i=[];let r=0,s=o,a=!VYLO.Type.getVariable(t,"baseType");if(l.length){for(let e=l.length-1;0<=e;e--)s&&(c=l[e]).type===t&&(l.splice(e,1),i.push(c),c.collectorCollected=!1,"function"==typeof c.onDumped&&c.onDumped(...n),r++,s--);if(o>r){const l=o-r;for(let e=0;e<l;e++)i.push(a?VYLO.newObject(t,...n):VYLO.newDiob(t,...n))}}else for(let e=0;e<o;e++)i.push(a?VYLO.newObject(t,...n):VYLO.newDiob(t,...n));return 1===i.length?i.pop():i}cleanInstance(e){if(e){if(e instanceof t.DiobConstructor){var o="Interface"===e.baseType||"Interface"===e.type||VYLO.Type.getInheritances(e.type).includes("Interface");e.color&&("object"==typeof e.color&&e.color.constructor===Object?(e.color.tint=16777215,e.color=e.color):e.color=null),"object"==typeof e.scale?(e.scale.x=e.scale.y=1,e.scale=e.scale):e.scale=1,o&&(e.hide(),"server"!==VYLO.World.getCodeType())&&VYLO.Client.removeInterfaceElement(e.getInterfaceName(),e,!0),e.playAnimation(),e.setTransition(),e.angle=0,e.alpha=1,e.xPos=0,e.yPos=0,o||(e.mapName=null,e.setLoc()),e.text="",e.composite="","Movable"===e.baseType&&e.move();for(const l of e.getOverlays())e.removeOverlay(l.type);for(const n of e.getFilters())e.removeFilter(n)}e.collectorCollected=!0,e.inTicker=null,"function"==typeof e.clean&&e.clean()}}}const l=new t;var n=o.P;export{n as Collector};